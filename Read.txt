from simpleai.search import CspProblem, backtrack, MOST_CONSTRAINED_VARIABLE, LEAST_CONSTRAINING_VALUE
import matplotlib.pyplot as plt
import numpy as np

grid = [i * 0.5 for i in range(-10, 11)]  # -5..5 step 0.5
TOL = 1e-9

def f_val(x, y):
    return abs((x + 1) * (x - 1) * (x - 2) + y * (y - 1))

def constraint_circle(vars_, vals):
    x, y = vals
    return abs(x * x + y * y - 1.0) <= TOL

def constraint_linear(vars_, vals):
    x, y = vals
    return x >= 2 * y - 1e-9

variables = ('x', 'y')
domains = {'x': grid, 'y': grid}
constraints = [
    (('x', 'y'), constraint_circle),
    (('x', 'y'), constraint_linear),
]

problem = CspProblem(variables, domains, constraints)

solutions = []
while True:
    sol = backtrack(problem,
                    variable_heuristic=MOST_CONSTRAINED_VARIABLE,
                    value_heuristic=LEAST_CONSTRAINING_VALUE,
                    inference=True)
    if not sol:
        break
    solutions.append(sol)

    tx, ty = sol['x'], sol['y']
    def make_blocker(tx_val, ty_val):
        def blocker(vars_, vals):
            x, y = vals
            return not (abs(x - tx_val) < 1e-9 and abs(y - ty_val) < 1e-9)
        return blocker
    problem.constraints.append((('x', 'y'), make_blocker(tx, ty)))

evaluated = [(f_val(s['x'], s['y']), s['x'], s['y']) for s in solutions]
evaluated.sort(key=lambda t: t[0])

print("Tổng nghiệm hợp lệ (từ SimpleAI):", len(evaluated))
for val, x, y in evaluated:
    print(f"  (x={x}, y={y}) -> f={val}")

if evaluated:
    minval = evaluated[0][0]
    minimizers = [(x, y) for f_, x, y in evaluated if abs(f_ - minval) <= 1e-9]
    print("\nGiá trị nhỏ nhất f =", minval)
    print("Điểm cực tiểu (hợp lệ):", minimizers)
else:
    print("Không tìm được nghiệm nào thoả ràng buộc.")

# ========== Vẽ biểu diễn trực quan giống hình bạn gửi ==========
X = np.linspace(-5, 5, 240)
Y = np.linspace(-5, 5, 240)
X, Y = np.meshgrid(X, Y)
Z = np.abs((X + 1) * (X - 1) * (X - 2) + Y * (Y - 1))

# lấy log để giống hình
Z_log = np.log1p(Z)

fig = plt.figure(figsize=(11, 7))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z_log, cmap='viridis', alpha=0.75)

# các cực tiểu lý thuyết
theoretical_minima = [(1,1), (1,0), (2,1), (2,0)]
for xx, yy in theoretical_minima:
    ax.scatter(xx, yy, np.log1p(f_val(xx, yy)), color='red', s=60)

# nghiệm tìm được từ CSP
for _, x, y in evaluated:
    ax.scatter(x, y, np.log1p(f_val(x, y)), color='blue', s=100, marker='^')

ax.set_title("Biểu diễn log1p(f(x,y)) và các cực tiểu")
ax.set_xlabel("x"); ax.set_ylabel("y"); ax.set_zlabel("log1p(f(x,y))")
plt.show()
